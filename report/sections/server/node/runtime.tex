\section{Runtime}
\label{section:noderuntime}

We define the session runtime for the \trole{Svr} endpoint
of the \tprotocol{Adder} protocol in Svr.ts,
named after the endpoint.
It exposes a \textbf{public API}
(\cref{lst:noderuntimepublicapi})
with seams for the developer to pass in the WebSocket server 
and application logic
(i.e. their handler implementations).
It is the responsibility of the developer to construct the
WebSocket server and set it up to listen for incoming connections.
Internally, it keeps a \textit{private API}
for executing the EFSM, when all participants have 
joined the session.

The role of the public API is to manage incoming connections and
wait for all participants to join the session 
(\cref{subsection:noderuntimepublic}), before
handing off to the private API to execute the EFSM
(\cref{subsection:noderuntimeprivate}).

\begin{figure}[!h]
\begin{lstlisting}[language=javascript,title=Svr.ts]
export class Svr {
	constructor(wss: WebSocket.Server,
				initialState: Implementation.S51) { ... }
	...
}

// Not exported to developer
class Session {
	private wss: WebSocket.Server;
	private initialState: Implementation.S51;
	private roleToSocket: RoleToSocket;
	...
}
\end{lstlisting}
\captionof{lstlisting}{Public and Private API of Session Runtime for Server Endpoint}
\label{lst:noderuntimepublicapi}
\end{figure}

\subsection{Managing Connections}
\label{subsection:noderuntimepublic}

\begin{itemize}
\item use set and partial object to keep track of pending connections
\item ws event listeners
\item forward reference that we need to manage cancellations here too
\end{itemize}

\subsection{Executing the EFSM}
\label{subsection:noderuntimeprivate}

The \texttt{Session} class executes the EFSM.
We define a transition function, \texttt{next()}, 
parameterised by the current state,
which invokes the handler defined by the develoepr
and performs the required channel actions for non-terminal states:

\begin{itemize}
\item 
For \textbf{send} states, the handler will
return the label and payload to be sent, along with the
successor state implementation. The transition function
should construct and send the message, 
and transition to the successor state.

\item
For \textbf{receive} states, we change the
message event listener on the WebSocket to
pass the incoming message to the handler.
The handler will return the successor state,
which the runtime can transition to.

\end{itemize}

We conceptualise this in \cref{lst:noderuntimesimple}.
The discriminated union lets the runtime figure out
the type of the current state.

\begin{figure}[!h]
\begin{lstlisting}[language=javascript,tabsize=2]
next(state: Implementation.Type) {
	switch (state.type) {
		case 'Send': {
			const [label, payload, succ]: (*@\hl{???}@*) = state.handler;	 (*@\label{line:noderuntimebadtype1}@*)
			this.send((*@\hl{???}@*), label, payload); (*@\label{line:noderuntimeunknownrole}@*)		
			return this.next(succ);
		}
		case 'Receive': {
			this.wss.onmessage = ({ data }) => {
				const { label, payload } = JSON.parse(data) as (*@\hl{???}@*); (*@\label{line:noderuntimebadtype2}@*)
				const succ: (*@\hl{???}@*) = state.handler[label](...payload); (*@\label{line:noderuntimebadtype3}@*)
				return this.next(succ);
			}
		}
		case 'Terminate': { return; }
	}
}
\end{lstlisting}
\captionof{lstlisting}{Conceptual EFSM Transition Function 
for Server-Side Endpoint}
\label{lst:noderuntimesimple}
\end{figure}

However, we still face problems with resolving types, as highlighted.
Just because we know that the current state is a send state,
we do not know \textit{which} particular state it is,
so we cannot accurately type the handler (\cref{line:noderuntimebadtype1}).
The same problem is amplified for the receive state:
we need to know the specific receive state in order
to correctly serialise the message (\cref{line:noderuntimebadtype2})
and interpret the successor state (\cref{line:noderuntimebadtype3}).
We see another problem with handling send states:
because we do not know the specific send state, we do not know which
participant to send the message to (\cref{line:noderuntimeunknownrole}).

These all reduce to the same core problem: the runtime
needs to know the specific state at compile-time\footnote{
Whether TypeScript ``compiles'' or ``transpiles''
(or even \textit{``transcompiles''} \cite{transcompiles}) to JavaScript
is not relevant to our work; we stick with compilation
and keep our terminology consistent.}.
We solve this through \textit{runtime polymorphism} instead, since
the specific type of \texttt{state} is known at runtime.
For each type of state, we define a common API that can be invoked
by the EFSM transition function. To achieve runtime polymorphism,
each concrete state must provide a specific implementation: 
this motivates our design for defining the discriminated union
using abstract classes with abstract methods 
(\cref{lst:nodeabstractclass}).

\begin{figure}[!h]
\begin{lstlisting}[language=javascript,tabsize=2]
abstract class ISend {
	type: 'Send' = 'Send';
	abstract performSend(
		next: EfsmTransitionHandler,
		send: (role: Roles.Peers, label: string, payload: any[]) 
			=> void,
	): void;
};

abstract class IReceive {
	type: 'Receive' = 'Receive';
	abstract prepareReceive(
		next: EfsmTransitionHandler,
		register: (from: Roles.Peers, messageHandler: MessageHandler)
			=> void,
	): void;
};
\end{lstlisting}
\captionof{lstlisting}{\dots}
\label{lst:nodeabstractclass}
\end{figure}

Using this approach,
we can pass the transition function and channel actions 
from the \texttt{Session} runtime class
to the individual state \texttt{Implementation} classes:
these are also generated by \fancyname{NodeTS}, so we
guarantee linear usage of channel resources by construction as well.
This \textit{significantly} simplifies the design of the runtime
(\cref{lst:noderuntime}),
because the transition function no longer needs to know the type 
of the specific state at compile-time.

\begin{figure}[!h]
\begin{lstlisting}[language=javascript,tabsize=2]
next(state: Implementation.Type) {
	switch (state.type) {
		case 'Send':
			return state.performSend(this.next, this.send);
		case 'Receive':
			return state.prepareReceive(this.next, this.register);
		case 'Terminal':
			return;
	}
}
\end{lstlisting}
\captionof{lstlisting}{Final EFSM Transition Function for Server-Side
Endpoint}
\label{lst:noderuntime}
\end{figure}

By passing the specific functions defined in the runtime
to the individual EFSM states, we can visualise our runtime
as a \textit{message passing} abstraction 
(\cref{fig:noderuntimeefsm}): the runtime uses the common
\texttt{performSend()} or \texttt{prepareReceive()} API
to delegate to the specialised implementation, which will in turn
ask the runtime to perform specialised channel actions using
the parameterised methods, and finally delegate back to
the runtime to transition to the specific successor state.

\begin{remark}
We need to be careful when passing \textit{instance} methods
as \textit{function} arguments 
-- namely, the semantics of \lstonelinejs{this} is different.
In short, we have to \textit{explicitly}
\texttt{bind()} the \texttt{Session} object
to the instance methods that we pass as function arguments:

\begin{lstlisting}[language=javascript,tabsize=2]
// Inside Session class constructor...
this.next = this.next.bind(this);
this.send = this.send.bind(this);
this.register = this.register.bind(this);
\end{lstlisting}

Not doing so will result in \lstonelinejs{this} taking
a different value 
(either the global object or \lstonelinejs{undefined}).
\end{remark}

We elaborate on how this mechanism
handles the sending and receiving of messages in
\cref{subsection:noderuntimesend,subsection:noderuntimereceive}
respectively.

\begin{figure}[!ht]
\centering
\includegraphics[width=0.5\textwidth]{NodeRuntimeEFSM}
\captionof{figure}{``Message Passing'' Abstraction of EFSM Execution for
Server Endpoints}
\label{fig:noderuntimeefsm}
\end{figure}

\subsection{Sending Messages}
\label{subsection:noderuntimesend}

This is rather straightforward: 
we show the generated code in \cref{lst:nodesend}.

\begin{figure}[!h]
\begin{lstlisting}[language=javascript,tabsize=2]
export class S54 extends ISend {
	constructor(private handler: Handler.S54) { super(); }

	performSend(
		next: EfsmTransitionHandler,
		send: (role: Roles.Peers, label: string, payload: any[]) 
			=> void
	) {
		const [label, payload, successor] = this.handler;
		send(Roles.Peers.Client, label, payload); (*@\label{line:nodesendrole}@*)
		return next(successor);
	}
}
\end{lstlisting}
\captionof{lstlisting}{\dots}
\label{lst:nodesend}
\end{figure}

We get the label, payload and successor implementation
directly from the handler implemented by the developer, 
accurately typed by how we define the handler API in EFSM.ts.
The developer does not need to specify which role
to send to: this is a sensible design choice, as we know this
from the Scribble protocol, so we do not need the developer 
to specify separately.
As a result, we generate the code to send the message
to the correct role (\cref{line:nodesendrole}).
We use the \texttt{send()} method passed down
by the runtime to commit our communication action:
the runtime will handle how to serialise the message and perform
the send. We guarantee that \texttt{send()} is called
\textbf{exactly once} by construction, thus channel linearity
is never violated.
Finally, we use the parameterised EFSM transition handler
to notify the rutime which specific state to transition to.

\subparagraph{Sending through WebSockets}
We define message structures as interfaces, which
are represented by objects. 
By convention in \fancyname{SessionTS},
we serialise messages into \textit{JavaScript Object Notation}
(or JSON) \cite{json} using the built-in \texttt{JSON.stringify()}
method.

\begin{lstlisting}[language=javascript]
send(role: Roles.Peers, label: string, payload: any[]) {
	this.roleToSocket[role].send(JSON.stringify({
		label, payload
	});
}
\end{lstlisting}

They are decoded using the same interface schema on the receiving end
using \texttt{JSON.parse()}: whilst the method return type is the
dynamic \lstonelinejs{any} type, 
we guarantee type safety by construction
as we performed the serialisation in the first place, so
we can safely interpret the deserialised content 
using a concrete type.

\subsection{Receiving Messages}
\label{subsection:noderuntimereceive}

We need to update the message event listener on the WebSocket
to use the developer's handler -- 
specific to the \textit{current state} -- 
to process the message.
Our approach is to keep the WebSocket message event listener
untouched, but define it in a way that allows \textit{dynamic} behaviour.
We walk through the concept implemented in (\cref{lst:noderuntimewsmsg}):

\begin{enumerate}
\item 
\texttt{Session} keeps track of the \textit{current}
message receive handler (\cref{line:noderuntimehandler}).
The \texttt{?} syntax denotes it is an \textit{optional}
type: not every state is a receive state, so there does not \textit{have} to
be an active message handler.

\item
The receive handler does \textit{not} need a specialised type
(\cref{line:msghandler}). The receive handler is defined in
the \texttt{Implementation} class of the concrete receive state,
so it will deserialise the message to the correct form.

\item
The \texttt{register()} method (\cref{line:register})
is passed to the \texttt{Implementation} class of the concrete
receive state, which will construct the message handler
around the developer's handler implementation and register it
with the runtime.

\item
When a message is received from the channel,
we dynamically process it with 
the current registered handler (\cref{line:callhandler}).
By MPST-safety, the incoming message must correspond
to the structure expected by the current receive state,
so correctness is preserved.
We encapsulate this dynamic behaviour in an instance method
and bind it as an event listener (\cref{line:wsbind})
for the WebSocket connection
of each non-server endpoint.
\end{enumerate}

\begin{figure}[!h]
\begin{lstlisting}[language=javascript,tabsize=2]
type MessageHandler = (message: any) => void; (*@\label{line:msghandler}@*)

class Session {
	private handler?: MessageHandler; (*@\label{line:noderuntimehandler}@*)

	constructor(...) {
		...
		Object.values(this.roleToSocket).
			.forEach(ws => ws.onmessage = this.receive.bind(this)); (*@\label{line:wsbind}@*)
		this.handler = undefined;
	}
	
	register(handler: MessageHandler) { this.handler = handler; } (*@\label{line:register}@*)

	receive({ data }: WebSocketMessage) {
		const handler = this.handler;
		this.handler = undefined;
		handler?.(data); (*@\label{line:callhandler}@*)
	}
}
\end{lstlisting}
\captionof{lstlisting}{Approach to Dynamic WebSocket Message Event Listener}
\label{lst:noderuntimewsmsg}
\end{figure}

We also show the generated code for the \texttt{Implementation}
class of the receive state in \cref{lst:nodereceive}
-- this should appear consistent
with the explanation above.

\begin{figure}[!h]
\begin{lstlisting}[language=javascript,tabsize=2]
export class S51 extends IReceive {
	
	constructor(private handler: Handler.S51) { super(); }

	prepareReceive(
		next: EfsmTransitionHandler,
		register: (from: Roles.Peers, messageHandler: MessageHandler)
			=> void
	) {
		const messageHandler = (message: any) => {
			const decoded = JSON.parse(message) as Message.S51;
			switch (decoded.label) {
				case Labels.S51.ADD: {
					const successor = 
						this.handler[decoded.label](...decoded.payload);
					return next(successor);
				}
				case Labels.S51.QUIT: {
					// Same as above...		
				}
			}            
		}
		register(Roles.Peers.Client, messageHandler);
	}
}
\end{lstlisting}
\captionof{lstlisting}{\dots}
\label{lst:nodereceive}
\end{figure}

Ideally, a more succinct (and direct) representation would be
\begin{lstlisting}[language=javascript]
const successor = this.handler[decoded.label](...decoded.payload);
return next(successor);
\end{lstlisting}

But this expresses a type dependency between \texttt{label}
and \texttt{payload}, which as discussed, cannot be implemented.
But message structures \textit{precisely} define a discriminated
union, so we handle this with a switch statement,
at the cost of having the same code in each case -- but
TypeScript does infer different types in each case statement,
so the duplicated code does serve a functional purpose.

Returning to \cref{lst:noderuntimewsmsg},
note that the type of the \texttt{handler} property is \textit{optional}
-- this hints at a consistency problem: 
\textit{how do we know that \texttt{this.handler} is set when
a message is received?}


\begin{itemize}
\item motivate the edge case that message can arrive in the websocket (in succession) before the handler is registered
\item motivate the edge case that message can arrive `out of protocol order' 
\item explain the double queue system and how that provides consistency -- emphasising that this works because of the single-threaded typescript runtime
\end{itemize}

\begin{figure}[!ht]
\centering
\begin{subfigure}[b]{0.8\textwidth}
\centering
\includegraphics[width=\textwidth]{NodeRuntimeReceive2}
\caption{Message processed before transitioning to receive state}
\label{subfig:nodereceivemsgfirst}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.8\textwidth}
\centering
\includegraphics[width=\textwidth]{NodeRuntimeReceive1}
\caption{Message processed after transitioning to receive state}
\label{subfig:nodereceivehandlefirst}
\end{subfigure}
\captionof{figure}{Possible Orderings for Handling Message Event and Preparing
Receive State}
\label{fig:nodereceivecompare}
\end{figure}

\subsection{Handling Termination}
WebSocket connections should be closed when the session terminates,
and both the browser endpoint and the server endpoint are capable
of closing connection. As we generate code for both, we define
a convention that the browser endpoint will initiate the WebSocket
close event.
As a result, we do nothing for this state at \cref{lst:noderuntime}.