\section{EFSM Encoding}
\label{section:nodeefsm}

We show the structure of the generated EFSM.ts file in
\cref{lst:nodeefsmfile}.
Note that the formal definition of the EFSM in 
\cref{section:scribbleefsm}
contains more than just states and the state transition function,
so we encode the additional information as well.
Each type of information is grouped into their own
\textit{namespace}, and are collectively exported in
the EFSM \textit{module} for the developer to use.

\begin{figure}
\begin{lstlisting}[language=javascript,tabsize=2,title=EFSM.ts]
// (*@\cref{subsection:nodeefsmroleslabelsmsg}@*)
export namespace Roles {...};
export namespace Labels {...};
export namespace Message {...};

// (*@\cref{subsection:nodeefsmhandlers}@*)
export namespace Handler {...};

// (*@\cref{subsection:nodeefsmimplementation}@*)
abstract class ISend {...};
abstract class IReceive {...};
abstract class ITerminal {...};
export namespace Implementation {...};

export type EfsmTransitionHandler =
	(implementation: Implementation.Type) => void;
export type MessageHandler = (message: any) => void;
\end{lstlisting}
\captionof{lstlisting}{Structure of Generated EFSM Encoding 
for Server Endpoint}
\label{lst:nodeefsmfile}
\end{figure}

\subsection{Roles, Labels, Messages}
\label{subsection:nodeefsmroleslabelsmsg}

We generate TypeScript constructs for these pieces of information
so they can be reused throughout the generated code, 
and in particular, the runtime.

\subparagraph{Roles}
The runtime needs to know the identifiers of participants involved
in the session, and who to send/receive from 
depending on the EFSM state.
We generate string enumerations, or \textit{enums}, for each 
participant in the protocol, \textit{excluding} the 
first person endpoint. 
The enum appropriately groups the collection
of participants involved and scales for multiparty sessions,
whilst making it simple to derive other types, e.g. a mapping from
participants (indexed by the enum) to WebSockets.

\subparagraph{Labels}
The runtime needs to decide which handler to invoke, based
on the label of the received message. Similarly, the developer needs
to provide handlers specifying their internal choice (e.g. which
message label to send) and how to handle external choice (e.g. 
how to handle received message with particular label).
For the same reason, we also generate string enums for message labels,
one enum per state. Enums are compatible with switch statements,
which can be used to dispatch messages to the correct handlers
in the runtime based on the message label. 
We give an example in \cref{lst:nodeefsmlabels}.

\begin{figure}[!ht]
\begin{lstlisting}[language=javascript,tabsize=2]
// Inside the Labels namespace...
export enum S51 { ADD = "ADD", QUIT = "QUIT", };
export enum S53 { RES = "RES", };
export enum S54 { THANKS = "THANKS", TERMINATE = "TERMINATE", };
\end{lstlisting}
\captionof{lstlisting}{Generated Label Enums for \trole{Svr} endpoint}
\label{lst:nodeefsmlabels}
\end{figure}

\subparagraph{Messages}
The handler APIs that we generate for developers
need to refer to the label identifier and payload type: 
we refer to this as the message structure, and encode this as a
Message Type. 
Each message is expressed as an interface with
properties for the label and payload.
These interfaces are grouped based on the EFSM state
they belong using \textit{union types}.
We illustrate this in \cref{lst:addersvrmsg}.
By expressing the payload type as a \textit{tuple}\footnote{
In TypeScript, a tuple is an array with fixed size
and known types for elements at each position.
},
we easily generalise our type definition to polyadic payloads.

\begin{figure}[!ht]
\begin{lstlisting}[language=javascript, tabsize=2]
// Inside the Message namespace...
export interface S54THANKS {
	label: Labels.S54.THANKS,
	payload: [string],
};
export interface S54TERMINATE {
	label: Labels.S54.TERMINATE,
	payload: [],
};

export type S54 = | S54THANKS | S54TERMINATE;
\end{lstlisting}
\captionof{lstlisting}{Generated Message Type Definition for State 54}
\label{lst:addersvrmsg}
\end{figure}

\subsection{Handler APIs}
\label{subsection:nodeefsmhandlers}

We collect the APIs that the developer needs to implement
under the \texttt{Handler} namespace. 
As a design choice, we \textit{do not} generate handlers for
terminal states, because the semantics of inactivity mean
there is nothing to handle.
We introduce the generated handlers for sending and receiving states.
These are non-terminal states that will involve the encoding of its
successor state. The reader will notice that, in the listings below,
the successor state is stated to be under the
\texttt{Implementation} namespace: we explain in 
\cref{subsection:nodeefsmimplementation}, but for now,
it is sufficient to acknowledge that those refer to the encoding
of the successor state.

\subparagraph{Send}
We model selections using a union type to
encapsulate the possible send actions, as shown in 
\cref{lst:addersvrsendhandler}.
Each send action is encoded as a tuple of
the label, the payload, and the successor state encoding.
We see some benefits from defining Message Types as interfaces:
TypeScript supports \textit{index type queries} to extract
named property types, so
\lstonelinejs{Message.S54THANKS['payload']} 
would resolve to \lstonelinejs{[string]},
based on the interface definition \cref{lst:addersvrmsg}.

\begin{figure}[!ht]
\begin{lstlisting}[language=javascript, tabsize=2]
// Inside the Handler namespace...
export type S54 = 
	| [Labels.S54.THANKS, Message.S54THANKS['payload'],
			Implementation.S52] 
	| [Labels.S54.TERMINATE, Message.S54TERMINATE['payload'], 
			Implementation.S52];
\end{lstlisting}
\captionof{lstlisting}{Generated Type for \trole{Svr} Send State
in \tprotocol{Adder} protocol}
\label{lst:addersvrsendhandler}
\end{figure}

We generalise deterministic send actions as a trivial \textit{selection}, 
as motivated from the theory (\cref{fig:globaltypes}),
so the encoding for State 53 in the \trole{Svr} FSM would be
the union of a single tuple.

\subparagraph{Receive}
We model branching using an interface to 
enumerate the possible branches, as shown in
\cref{lst:addersvrreceivehandler}.
As with send states,
we generalise deterministic receive actions as a trivial \textit{branch},
which would be an interface with one property. 

\begin{figure}[!ht]
\begin{lstlisting}[language=javascript,tabsize=2]
// Inside the Handler namespace...
export type S51 = {
	[Labels.S51.ADD]: (...payload: Message.S51ADD['payload']) =>
		Implementation.S53,
	[Labels.S51.QUIT]: (...payload: Message.S51QUIT['payload']) => 
		Implementation.S54,
}
\end{lstlisting}
\captionof{lstlisting}{Generated Type for \trole{Svr} Receive State
in \tprotocol{Adder} protocol}
\label{lst:addersvrreceivehandler}
\end{figure}

The interface properties are defined by the 
labels of the permitted receive actions:
the square-bracket notation means that the property name
is derived from the value of the enclosing variable,
so \lstonelinejs{[Labels.S51.ADD]} resolves to the
\lstonelinejs{'ADD'} string. 

The interface values are functions parameterised by
the message payload, and must return the successor state encoding.
We see another benefit of defining the payload in Message Types
as a tuple: we can define the receive handler parameter
using the \textit{spread syntax}, which allows the tuple
expression to be expanded into a list of function arguments. 
More concretely, as shown in \cref{lst:nodeefsmspread},
it allows the developer to pattern match on the
individual payload values (\cref{line:yesspread}) 
rather than defining their function to expect a tuple 
and manually destructing it (\cref{line:nospread}),
so the former is more intuitive.

\begin{figure}[!ht]
\begin{lstlisting}[language=javascript,tabsize=2]
const withSpread = (x: number, y: number) => {...} (*@\label{line:yesspread}@*)
const withoutSpread = (payload: [number, number]) => {...} (*@\label{line:nospread}@*)

const handler1: Handler.S51 = { ADD: withSpread		, ... };	// OK
const handler2: Handler.S51 = { ADD: withoutSpread, ... };	// OK
\end{lstlisting}
\captionof{lstlisting}{Example Handler Signature 
Compatible with Spread Syntax}
\label{lst:nodeefsmspread}
\end{figure}

\subsection{Wrapping Handlers in ``Implementations''}
\label{subsection:nodeefsmimplementation}

The behaviour of the runtime is dependent on the current state,
so it needs a way to distinguish between
all the different states -- one can think of this as implementing
the state transition function from the theory, which is analogue to 
overloading a \texttt{next()} method for each state.
Due to limitations in the TypeScript language, this would have to
be some sort of switch statement, with the \texttt{next()}
method parameterised by some base type assignable to all states.
Currently, the state is only determined by the handler
to be implemented by the developer, so the switch statement
and base type would have to be defined on the handler APIs.

Unfortunately, this is not practical. 
Handlers for send states are union types and
handlers for receive states are interfaces,
both of which are not supported 
by the \lstonelinejs{instanceof}
operator.

\subsubsection{Distinguishing Handlers using Conditional Types}

We attempt to address this by defining an enum of state identifiers
for each type of state (i.e. an enum for send states, 
an enum for receive states)
upon which to execute the EFSM, which solves the switch statement
problem.
Now, we are left with defining a mapping between the 
state identifier enum to the handler type. This construct would be
analogue to \textit{dependent types}, which again, is not a feature
of the TypeScript type system.

We try to define type dependencies using
\textit{conditional types} in TypeScript.
A conditional types is a type-level expression
\begin{lstlisting}[language=javascript,numbers=none]
T extends U ? X : Y;
\end{lstlisting}
which reads, \textit{if \texttt{T} is assignable to \texttt{U},
then the type is \texttt{X}; otherwise, the type is \texttt{Y}}.

Combined with \textit{generic constraints}\footnote{
\lstonelinejs{<T extends U>} defines a generic type \texttt{T}
and enforces that it must be a type assignable to \texttt{U}.
},
we can approximate the dependency between the state identifier
enum and the generated handler API using something
similar to \cref{lst:conditionaltypes}.

\begin{figure}[!h]
\begin{lstlisting}[language=javascript,tabsize=2]
enum SendState { S1, S3, ... };
enum ReceiveState { S2, S4, ... };
type State = SendState | ReceiveState;

type SendHandler<S extends SendState> = 
	S extends SendState.S1 ? Handler.S1 :
	S extends SendState.S3 ? Handler.S3 : ... ;

type ReceiveHandler<S extends ReceiveState> = 
	S extends ReceiveState.S2 ? Handler.S2 :
	S extends ReceiveState.S4 ? Handler.S4 : ... ;
\end{lstlisting}
\captionof{lstlisting}{Approximating Type Dependency
using \textit{Conditional Types}}
\label{lst:conditionaltypes}
\end{figure}

We intend to use this construct when defining the EFSM transition
function for the runtime, for each type of state,
so the method signature for transitioning to send states
would resemble \cref{lst:conditionaltransitionfunction}

\begin{figure}[!h]
\begin{lstlisting}[language=javascript,numbers=none]
declare function transitionToSend<S extends SendState>(
	stateId: S, handler: SendHandler<S>
);
\end{lstlisting}
\captionof{lstlisting}{EFSM Transition Function 
using Conditional Types}
\label{lst:conditionaltransitionfunction}
\end{figure}

Unfortunately, this approach does not work for the simple fact that
conditional types were not designed to be exploited in this manner.
The main limitation of conditional types is its 
\textit{distributivity} when the type ``parameter'' is an
union type (which is the case for enums, as
\texttt{S = SendState.S1 | SendState.S3 | ...}), where

\begin{lstlisting}[language=javascript,numbers=none]
(T1 | T2) extends U ? X : Y
\end{lstlisting}

results in the conditional type being \textit{distributed}
among each constituent,

\begin{lstlisting}[language=javascript,numbers=none]
(T1 extends U ? X : Y) | (T2 extends U ? X : Y)
\end{lstlisting}

so the type expression returns to an union type,

\begin{lstlisting}[language=javascript,numbers=none]
X | Y
\end{lstlisting}

Returning to \cref{lst:conditionaltransitionfunction}, 
the type of \texttt{handler} will end up being a union type, 
rather than the ``dependent type''
construct we were hoping for.

\subsubsection{Distinguishing Handlers using Discriminated Unions}

Instead, we leverage \textit{discriminated unions}: all members
of the union type share a common property (the \textit{discriminant})
of which they each define an
unique value for, so that the TypeScript Compiler can refine the union
to the specific constituent upon checking the value of the discriminant
(e.g. applying a switch statement).

For the time being,
it is sufficient to understand that for each EFSM state,
in addition to the API defined under the
\texttt{Handler} namespace, it also has a wrapper API defined under
the \texttt{Implementation} namespace (\cref{lst:nodeefsmimplementation}),
which defines the \texttt{type}
discriminant property internally. This explains why the successor
state encodings in 
\cref{lst:addersvrsendhandler,lst:addersvrreceivehandler}
were defined as such.

\begin{figure}[!h]
\begin{lstlisting}[language=javascript,tabsize=2]
abstract class ISend { type: 'Send' = 'Send'; ... }
abstract class IReceive { type: 'Receive' = 'Receive'; ... }

export namespace Implementation {

	export class S51 extends IReceive {
		constructor(private handler: Handler.S51) { super(); }
		...
	}
	...
};
\end{lstlisting}
\captionof{lstlisting}{Discriminated Unions in EFSM 
for Server-Side Endpoints}
\label{lst:nodeefsmimplementation}
\end{figure}

We discuss our runtime implementation shortly 
(\cref{section:noderuntime}), where we disclose more details regarding
the role of the \texttt{Implemenation} wrapper API in
the runtime.