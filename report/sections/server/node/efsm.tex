\section{EFSM Encoding}
\label{section:nodeefsm}

We show the structure of the generated EFSM.ts file in
\cref{lst:nodeefsmfile}.
Note that the formal definition of the EFSM in 
\cref{section:scribbleefsm}
contains more than just states and the state transition function,
so we encode the additional information as well.
Each type of information is grouped into their own
\textit{namespace}, and are collectively exported in
the EFSM \textit{module} for the developer to use.

\begin{figure}
\begin{lstlisting}[language=javascript,tabsize=2,title=EFSM.ts]
// (*@\cref{subsection:nodeefsmroleslabelsmsg}@*)
export namespace Roles {...};
export namespace Labels {...};
export namespace Message {...};

// (*@\cref{subsection:nodeefsmhandlers}@*)
export namespace Handler {...};

// (*@\cref{subsection:nodeefsmimplementation}@*)
abstract class ISend {...};
abstract class IReceive {...};
abstract class ITerminal {...};
export namespace Implementation {...};

export type EfsmTransitionHandler =
	(implementation: Implementation.Type) => void;
export type MessageHandler = (message: any) => void;
\end{lstlisting}
\captionof{lstlisting}{Structure of Generated EFSM Encoding 
for Server Endpoint}
\label{lst:nodeefsmfile}
\end{figure}

\subsection{Roles, Labels, Messages}
\label{subsection:nodeefsmroleslabelsmsg}

We generate TypeScript constructs for these pieces of information
so they can be reused throughout the generated code, 
and in particular, the runtime.

\subparagraph{Roles}
The runtime needs to know the identifiers of participants involved
in the session, and who to send/receive from 
depending on the EFSM state.
We generate string enumerations, or \textit{enums}, for each 
participant in the protocol, \textit{excluding} the 
first person endpoint. 
The enum appropriately groups the collection
of participants involved and scales for multiparty sessions,
whilst making it simple to derive other types, e.g. a mapping from
participants (indexed by the enum) to WebSockets.

\subparagraph{Labels}
The runtime needs to decide which handler to invoke, based
on the label of the received message. Similarly, the developer needs
to provide handlers specifying their internal choice (e.g. which
message label to send) and how to handle external choice (e.g. 
how to handle received message with particular label).
For the same reason, we also generate string enums for message labels,
one enum per state. Enums are compatible with switch statements,
which can be used to dispatch messages to the correct handlers
in the runtime based on the message label. 
We give an example in \cref{lst:nodeefsmlabels}.

\begin{figure}[!ht]
\begin{lstlisting}[language=javascript,tabsize=2]
// Inside the Labels namespace...
export enum S51 { ADD = "ADD", QUIT = "QUIT", };
export enum S53 { RES = "RES", };
export enum S54 { THANKS = "THANKS", TERMINATE = "TERMINATE", };
\end{lstlisting}
\captionof{lstlisting}{Generated Label Enums for \trole{Svr} endpoint}
\label{lst:nodeefsmlabels}
\end{figure}

\subparagraph{Messages}
The handler APIs that we generate for developers
need to refer to the label identifier and payload type: 
we refer to this as the message structure, and encode this as a
Message Type. 
Each message is expressed as an interface with
properties for the label and payload.
These interfaces are grouped based on the EFSM state
they belong using \textit{union types}.
We illustrate this in \cref{lst:addersvrmsg}.
By expressing the payload type as a \textit{tuple}\footnote{
In TypeScript, a tuple is an array with fixed size
and known types for elements at each position.
},
we easily generalise our type definition to polyadic payloads.

\begin{figure}[!ht]
\begin{lstlisting}[language=javascript, tabsize=2]
// Inside the Message namespace...
export interface S54THANKS {
	label: Labels.S54.THANKS,
	payload: [string],
};
export interface S54TERMINATE {
	label: Labels.S54.TERMINATE,
	payload: [],
};

export type S54 = | S54THANKS | S54TERMINATE;
\end{lstlisting}
\captionof{lstlisting}{Generated Message Type Definition for State 54}
\label{lst:addersvrmsg}
\end{figure}

\subsection{Handler APIs}
\label{subsection:nodeefsmhandlers}

We collect the APIs that the developer needs to implement
under the \texttt{Handler} namespace. 
As a design choice, we \textit{do not} generate handlers for
terminal states, because the semantics of inactivity mean
there is nothing to handle.
We introduce the generated handlers for sending and receiving states.
These are non-terminal states that will involve the encoding of its
successor state. The reader will notice that, in the listings below,
the successor state is stated to be under the
\texttt{Implementation} namespace: we explain in 
\cref{subsection:nodeefsmimplementation}, but for now,
it is sufficient to acknowledge that those refer to the encoding
of the successor state.

\subparagraph{Send}
We model selections using a union type to
encapsulate the possible send actions, as shown in 
\cref{lst:addersvrsendhandler}.
Each send action is encoded as a tuple of
the label, the payload, and the successor state encoding.
We see some benefits from defining Message Types as interfaces:
with deterministic properties, we can index into the message type
to access the property's type, 
e.g. \lstonelinejs{Message.S54THANKS['payload']} 
would resolve to
\lstonelinejs{[string]},
based on \cref{lst:addersvrmsg}.

\begin{figure}[!ht]
\begin{lstlisting}[language=javascript, tabsize=2]
// Inside the Handler namespace...
export type S54 = 
	| [Labels.S54.THANKS, Message.S54THANKS['payload'],
			Implementation.S52] 
	| [Labels.S54.TERMINATE, Message.S54TERMINATE['payload'], 
			Implementation.S52];
\end{lstlisting}
\captionof{lstlisting}{Generated Type for \trole{Svr} Send State
in \tprotocol{Adder} protocol}
\label{lst:addersvrsendhandler}
\end{figure}

We generalise deterministic send actions as a trivial \textit{selection}, 
as motivated from the theory (\cref{fig:globaltypes}),
so the encoding for State 53 in the \trole{Svr} FSM would be
the union of a single tuple.

\subparagraph{Receive}
We model branching using an interface to 
enumerate the possible branches, as shown in
\cref{lst:addersvrreceivehandler}.
As with send states,
we generalise deterministic receive actions as a trivial \textit{branch},
which would be an interface with one property. 

\begin{figure}[!ht]
\begin{lstlisting}[language=javascript,tabsize=2]
// Inside the Handler namespace...
export type S51 = {
	[Labels.S51.ADD]: (...payload: Message.S51ADD['payload']) =>
		Implementation.S53,
	[Labels.S51.QUIT]: (...payload: Message.S51QUIT['payload']) => 
		Implementation.S54,
}
\end{lstlisting}
\captionof{lstlisting}{Generated Type for \trole{Svr} Receive State
in \tprotocol{Adder} protocol}
\label{lst:addersvrreceivehandler}
\end{figure}

The interface properties are defined by the 
labels of the permitted receive actions:
the square-bracket notation means that the property name
is derived from the value of the enclosing variable,
so \lstonelinejs{[Labels.S51.ADD]} resolves to the
\lstonelinejs{'ADD'} string. 

The interface values are functions parameterised by
the message payload, and must return the successor state encoding.
We see another benefit of defining the payload in Message Types
as a tuple: we can define the receive handler parameter
using the \textit{spread syntax}, which allows the tuple
expression to be expanded into a list of function arguments. 
More concretely, as shown in \cref{lst:nodeefsmspread},
it allows the developer to pattern match on the
individual payload values (\cref{line:yesspread}) 
rather than defining their function to expect a tuple 
and manually destructing it (\cref{line:nospread}),
so the former is more intuitive.

\begin{figure}[!ht]
\begin{lstlisting}[language=javascript,tabsize=2]
const withSpread = (x: number, y: number) => {...} (*@\label{line:yesspread}@*)
const withoutSpread = (payload: [number, number]) => {...} (*@\label{line:nospread}@*)

const handler1: Handler.S51 = { ADD: withSpread		, ... };	// OK
const handler2: Handler.S51 = { ADD: withoutSpread, ... };	// OK
\end{lstlisting}
\captionof{lstlisting}{Example Handler Signature 
Compatible with Spread Syntax}
\label{lst:nodeefsmspread}
\end{figure}

\subsection{Wrapping Handlers in ``Implementations''}
\label{subsection:nodeefsmimplementation}

The behaviour of the runtime is dependent on the current state,
so it needs a way to distinguish between
all the different states -- one can think of this as implementing
the state transition function from the theory, which is analogue to 
overloading a \texttt{next()} method for each state.
Due to limitations in the TypeScript language, this would have to
be some sort of switch statement, with the \texttt{next()}
method parameterised by some base type assignable to all states.
Currently, the state is only determined by the handler
to be implemented by the developer, so the switch statement
and base type would have to be defined on the handler APIs.

Unfortunately, this is not practical. 
Handlers for send states are union types and
handlers for receive states are interfaces,
both of which are not supported 
by the \lstonelinejs{instanceof}
operator.

We attempt to address this by defining an enum of state identifiers
for each type of state (i.e. an enum for send states, 
an enum for receive states)
upon which to execute the EFSM, which solves the switch statement
problem.
Now, we are left with defining a mapping between the 
state identifier enum to the handler type. This construct would be
analogue to \textit{dependent types}, which again, is not a feature
of the TypeScript type system.


\begin{itemize}
\item need a way for the runtime to distinguish between states (implementation)
\item attempt at using conditional types, but because they handle conditional union types in a distributed way (give example), cannot be statically typed
\item alternative -- use discriminated union by wrapping in an Implementation class
\item all non-terminal states will `return' the successor implementation -- very difficult to resolve in the type-checker in the runtime (give example of what it may look like) -- solve by giving each state implementation the `advance' function to respect the event-driven nature of everything, so they can call it on completion
\item visualise the interaction between runtime and states as a sequence diagram for message passing
\end{itemize}