\section{Performance Benchmarks}

Whilst web applications that implement our generated APIs enjoy
communication safety guarantees, the presence of the session runtime acts
as an additional layer of abstraction between the application logic and the
WebSocket transport, which is likely to present a performance trade-off.

\begin{figure}[!ht]
\begin{lstlisting}[language=Scribble]
global protocol PingPong(role Client, role Svr) {
	PING(number) from Client to Svr;
	choice at Svr {
		PONG(number) from Svr to Client;
		do PingPong(Client, Svr);
	} or {
		BYE(number) from Svr to Client;	
	}
}
\end{lstlisting}
\captionof{lstlisting}{Ping Pong Protocol}
\label{lst:pingpong}
\end{figure}

To measure the overhead of our implementation, we compare the
execution time of an interactive web application implementing the
Ping Pong protocol (\cref{lst:pingpong}) using our generated APIs,
against implementations of the protocol \textit{without} session types.

We parameterise the Ping Pong protocol by $n > 0$, the number of
round-trip messages. This is standardised in the application logic
across experiments.
Upon establishing a connection, the experiment proceeds as follow:

\begin{enumerate}

\item \trole{Client} sends \tmsg{PING($m$:number)} to \trole{Svr}, 
with $m = 0$ initially.

\item \trole{Svr} receives \tmsg{PING($m$:number)}, and
conditionally responds based on $n$:

\begin{enumerate}
\item If $m + 1 < n$, then \trole{Svr} replies \tmsg{PONG($m + 1$)}.
\trole{Client} responds to \tmsg{PONG} by returning to
step 1 with $m$ set as the payload from \tmsg{PONG}.

\item Otherwise, $m + 1 = n$, then \trole{Svr} responds with 
\tmsg{BYE($m + 1$)}, as $n$ round trips have taken place. 
\trole{Client} responds to \tmsg{BYE} by 
closing the connection, thus ending the experiment.
\end{enumerate}

\end{enumerate}

We note that the Ping Pong protocol implements a \textit{binary} session. 
It would be interesting to observe the overhead in a \textit{multiparty}
context, but due to limited time constraints, we were unable to 
extend our benchmarking suite to support multiple browser targets.
Benchmarking multiparty protocols would also require writing multiple
distinct React applications using the generated APIs -- as this is currently
a manual process, doing this for multiple roles requires more time than
available.

\subsection{Setup}

In order to measure the overhead as accurately as possible,
we outline the logic that all implementations must follow:

\subparagraph{Ping Pong \trole{Client} on React:}
\begin{itemize}

\item All \trole{Client}s implement the same user interface 
(\cref{fig:pingpongclient}), rendering
a \texttt{<button>} which triggers the send, and
a \texttt{<div>} captioned with the number of \tmsg{PONG}s received.

\item \trole{Client}s will use the React Context API \cite{reactcontext}
for application state management, i.e. the number of \tmsg{PONG}s received. 
We wrap the session logic in a \texttt{<Benchmark>} component 
that acts as the \texttt{ContextProvider} using its component state.

\item To automate the benchmark, we use the React Refs API \cite{reactrefs}
to access the DOM \texttt{<button>} node programmatically, in order to
simulate the click event and send a \tmsg{PING} message upon establishing
the WebSocket connection, or upon receiving a \tmsg{PONG}.

\item We use the production build generated by 
\texttt{create-react-app} \cite{cra} for all experiments, which performs the
transpilation into JavaScript. We serve the production build using the
\texttt{serve} package \cite{npmserve} available on \texttt{npm}.

\end{itemize}

\begin{figure}[!ht]
\captionof{figure}{User interface of Ping Pong \trole{Client}}
\label{fig:pingpongclient}
\end{figure}

\subparagraph{Ping Pong \trole{Svr} on Node:}
\begin{itemize}

\item We use the built-in \texttt{console.time} function to record
the execution time of all experiments. 
The timer starts when a WebSocket connection has been established at
\trole{Server}, and stops when on a \texttt{CloseEvent}.

\item To observe the execution pattern, the \trole{Svr} will log the running 
elapsed time for every \tmsg{PING} message received.

\item All \trole{Svr}s run the benchmarks without a real web browser,
using headless browsing functionality from 
the Zombie.js \cite{zombie} package.

\item The entry point to the \trole{Svr} logic is parameterised by the
number of messages, $n$, configured through an environment variable
passed through the command line.

\item We use the transpiled JavaScript versions of all \trole{Svr}
for the experiments.

\end{itemize}

The interested reader may follow the instructions under
\texttt{benchmarks/README.md} in the project repository \cite{repo}
to run the benchmarks and visualise the logs using the interactive
notebook in the same directory.

We run the experiments under a network of latency 0.165ms
(64 bytes ping), and repeat each experiment 20 times.
Execution time measurements  are taken using a machine 
equipped with Intel i7-4850HQ CPU (2.3 GHz, 4 cores, 8 threads), 
16 GB RAM, macOS operating system version 10.15.4, 
Node.js runtime version 12.12.0, and
TypeScript compiler version 3.7.4.
We standardise all packages used in the front- and back-end
implementations across experiments. Details can be found in their
corresponding \texttt{package.json} manifests (\cref{appendix:eval}).

We run our experiments using three implementations of the Ping Pong protocol:

\subparagraph{bare:}
The \texttt{bare} implementation directly interfaces with 
WebSocket primitives for sending and receiving. 
The implementation executes the Ping Pong protocol, but does not 
guarantee communication safety by construction -- e.g. the user can click
the \tmsg{PING} button multiple times before a \tmsg{PONG} message 
is received, violating channel linearity. 
This represents the typical developer implementation without using the
MPST framework.

\subparagraph{bare_safe:}
The \texttt{bare_safe} implementation also directly interfaces with
WebSocket primitives for communication, but assumes the developer
implements minimal viable workarounds to address the lack of
communication safety. Here, the developer renders an inactive version
of the \tmsg{PING} button when the \tmsg{PING} message has been sent
but a response has yet to be received; a \texttt{visible} boolean flag
is used to explicitly manage which \texttt{<button>} to render.

\subparagraph{mpst:}
The \texttt{mpst} implementation follows the MPST framework and
uses the APIs generated from \fancyname{SessionTS}, so it enjoys the
communication safety guarantees from our methodology.

\subsection{Execution Pattern}
We compare the execution patterns of exchanging 10,000 Ping-Pongs
throughout 20 repeated experiments across the three implementations.
We visualise the elapsed time with respect to the number of \tmsg{PING}s
received in \cref{fig:execution}.

\begin{figure}[!h]
\centering
\begin{subfigure}[b]{0.3\textwidth}
\centering
\includegraphics[width=\textwidth]{execbare10000}
\caption{\texttt{bare}}
\label{fig:executionbare}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.3\textwidth}
\centering
\includegraphics[width=\textwidth]{execbaresafe10000}
\caption{\texttt{bare_safe}}
\label{fig:executionbaresafe}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.3\textwidth}
\centering
\includegraphics[width=\textwidth]{execmpst10000}
\caption{\texttt{mpst}}
\label{fig:executionmpst}
\end{subfigure}
\captionof{figure}{Comparison of Execution Pattern for 10,000 Ping-Pongs}
\label{fig:execution}
\end{figure}



\subsection{Overhead}
We compare the total execution time (\textit{Exe. Time}) 
and execution time per round trip (\textit{Exe. Time / Ping-Pong}) -- 
averaged over 20 repeated experiments -- across the three implementations,
for $n \in \{10^2, 10^3, 10^4\}$.
We summarise the results in \cref{table:overhead}.

\renewcommand{\arraystretch}{1.5}
\begin{table}[!h]
\centering
\begin{tabular}{||c||c|c|c||c|c|c||}
\hline
\multirow{2}{*}{$n$} & 
\multicolumn{3}{c||}{Exe. Time} & 
\multicolumn{3}{c||}{Exe. Time / Ping-Pong} \\
\cline{2-7}
 & \texttt{bare} & \texttt{bare_safe} & \texttt{mpst} 
 & \texttt{bare} & \texttt{bare_safe} & \texttt{mpst} \\
\hline\hline
$10^2$ & 89.64ms & 107.09ms & 186.23ms & 0.90ms & 1.07ms & 1.86ms \\
$10^3$ & 642.92ms & 663.91ms & 1155.48ms & 0.64ms & 0.66ms & 1.16ms \\
$10^4$ & 3542.16ms & 3837.97ms & 7015.25ms & 0.35ms & 0.38ms & 0.70ms \\
\hline
\end{tabular}
\captionof{table}{Comparison of Execution Time for 
100, 1,000 and 10,000 Ping-Pongs}
\label{table:overhead}
\end{table}
\renewcommand{\arraystretch}{1}

We note that the addition of a session runtime for all roles in the 
\texttt{mpst} implementation \textit{does} incur a performance overhead. 
This is made apparent when looking closely at 
\textit{Exe. Time / Ping-Pong};
we visualise this in \cref{fig:timepermsg}.

\begin{figure}[!h]
\centering
\includegraphics[width=\textwidth]{timepermsg}
\captionof{figure}{Comparing Average Time per Ping-Pong 
Across Implementations}
\label{fig:timepermsg}
\end{figure}

The \texttt{mpst} implementation records greater round trip times compared
to both \texttt{bare} and \texttt{bare_safe} variants. This is expected,
as \dots