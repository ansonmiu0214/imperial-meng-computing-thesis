\section{Session Delegation: \fancyname{ATM}}
\label{section:evalatm}

The developer may define a communication protocol
in a way that requires implicit \textit{session delegation}
upon connection: when the browser endpoint connects
to the server endpoint, the server delegates a private channel
to carry out the interactions specified by the protocol,
whilst concurrently accepting new connections.
We illustrate the limitations of our work with respect
to supporting session delegation, albeit this is also
a limiting factor in similar existing work 
\cite{PureScript2019,MVU2020}.

Consider an \tprotocol{ATM} protocol involving a 
\trole{Bank} server endpoint and 
a \trole{Client} browser endpoint,
as presented in \cref{lst:atm}.
This is a recursive protocol, where the \trole{Client}
can choose to \tmsg{WITHDRAW} or \tmsg{DEPOSIT} some money
into their account, or \tmsg{QUIT}.
For \tmsg{WITHDRAW} and \tmsg{DEPOSIT} operations,
the \trole{Bank} will respond with the updated \tmsg{BALANCE},
or a \tmsg{FAIL}ure message if an operation fails (specifically,
\tmsg{WITHDRAW}ing more money than available).

\begin{figure}[!ht]
\begin{lstlisting}[language=Scribble, tabsize=2]
module ATM;

global protocol ATM(role Bank, role Client) {
	choice at Client {
		// The string contains the client's bank account ID
		WITHDRAW(string, number) from Client to Bank;
		choice at Svr {
			BALANCE(number) from Bank to Client;		
		} or {
			FAIL(string) 		from Bank to Client;		
		}
		do ATM(Bank, Client);
	} or {
		DEPOSIT(string, number) from Client to Bank;
		BALANCE(number) 				from Bank to Client;
		do ATM(Bank, Client);
	} or {
		QUIT(string) from Client to Bank;
		BYE() 			 from Bank to Client;	
	}
}
\end{lstlisting}
\captionof{lstlisting}{The \tprotocol{ATM} Protocol}
\label{lst:atm}
\end{figure}

An important detail is that, for any operation,
the \trole{Client} provides their bank account ID
in the message. By specifying the communication protocol
in this way, the developer intends to allow the
\trole{Bank} to manage the operations of multiple
\trole{Client}s concurrently.
More precisely, the developer makes an assumption
that the interactions specified in the protocol
are delegated to a private channel upon connection.

However, the runtime generated by \nodecodegen
does not make this assumption, so we do not get
the behaviour intended by the developer. If a second
\trole{Client} tries to connect to the \trole{Bank},
the connection request will be unsuccessful because
the role is already occupied.
Interested readers can validate this
behaviour by running the full implementation available
on GitHub\footnote{
\url{https://github.com/ansonmiu0214/SessionTS-Examples/ATM}
}.

At the same time, the runtime generated by \nodecodegen
can be adapted to ``support'' \textit{binary} session delegation.
The generated runtime includes
an \trole{Svr} class used to listen for
and manage incoming connections, and a
private \texttt{Session} class to execute the EFSM.
When the instance of the \trole{Svr} class
is no longer waiting for participants,
it delegates to a fresh instance of the \texttt{Session} class
to execute the protocol.
To support delegation, we can simply modify this piece of 
logic to also create a fresh instance of the \trole{Svr}
class to concurrently manage new connections, whilst the
instance of the \texttt{Session} class is bound to the
participants that have already joined.
We show this workaround in \cref{lst:atmdelegation} -- 
specifically, on \cref{line:atmdelegation}.

\begin{figure}[!h]
\begin{lstlisting}[language=javascript]
// ATM delegation workaround (*@\label{line:atmdelegation}@*)
\end{lstlisting}
\captionof{lstlisting}{Workaround for Binary Session
Delegation in \tprotocol{ATM} protocol}
\label{lst:atmdelegation}
\end{figure}

This workaround does not generalise well for
\textit{multiparty} session delegation. 
Suppose we want to do the same for the 
\tprotocol{Noughts and Crosses} protocol discussed
in \cref{section:evalcodegame}.
Assume an user connects as \trole{P1} and the game server
is still waiting for \trole{P2}. If another user attempts
to connect as \trole{P1}, connection will be unsuccessful
as the first game hasn't began yet -- this workaround will
only begin accepting connections again \textit{once}
the protocol begins executing.
Formally supporting session delegation will also require
extensions to the Scribble language, since we should not
make the assumption that all protocols require
session delegation upon connection.

This would be an interesting area of future work and
enable \codegen to support a wider range of protocols
for webservices; we discuss further in \cref{section:future}.