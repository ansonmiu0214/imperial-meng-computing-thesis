\subsubsection{New Structure (similar to ECOOP2017):}
\begin{itemize}

\item \textbf{Section 1.1:}

Interactive webapps over WebSockets, harder to guarantee communication safety

\item
Example protocol similar to travel agency  -- motivate that it is difficult to manually verify communication safety

\begin{itemize}
\item traveller enquires availability, flight server replies yes/no then traveller confirms/denies.
\item The flight server will reserve the seat until the traveller denies.
\item Source of hidden bugs -- traveller may enquire twice (e.g. click twice), but server processes one enquiry, so one seat is held up for no reason
\end{itemize} 

\item MPST framework can be applied for webapps.
This is solved by existing work PureScript and MVU2020.

\item \textbf{Problem1}: 

existing work provides a workflow for session typed web development, but requires the developer to compromise by adapting to programming paradigms and practices not conventional for modern web programming. E.g. functional paradigm, sequential UI framework, PureScript and LINKS not interoperable with the ever-growing universe of JavaScript libraries. These compromises limit the usability of MPST framework
for web development.

\item \textbf{PRoblem2}: 

existing work based on WebSocket transport, which
is simple to reason about. But WebSocket transport enforces a server-centric
network configuration, so existing work isn't expressive enough for
more general protoocls. Suppose traveler contacts agency first to get a quote and then compare (similar to 2-buyer). Existing work cannot implement this.

\item \textbf{Section 1.2: }

Our objective is to present a novel variant of MPST framework
that is compatible / supports the flexibility of modern web programming.
We address the two problems in two parts:

\item We solve problem 1 in part 1: 

SessionTS is API generation workflow based on MPST, which
provides developers with same communication safety guarantees in a way that is idiomatic for modern web programming. We use industry tools (TS/Node/REact), compatible with async logic, error handling specific to web (e.g. client disconnection)

\item We solve problem 2 in part 2:

develop novel theory for routed MPST which lets us implement non-server-centric commuication structures over a server-centric network topology, prove
that our theory preserves properties like communication safety, deadlock freedom, etc.

\item Section 1.3: diagram similar to FZ for outline

\end{itemize}

% Aim of introductio: motivate what is the problem 
%(session types fix web, PureScript and LINKS have two problems: 
%implementation -- not using mainstream stuff, 
%theory -- websocket transport restricts protocols)


\section{Motivation}
\label{section:intro}

Modern interactive web applications aim to 
provide a highly responsive user experience by 
minimising the communication latency between clients and servers. 
Whilst the \textit{HTTP} request-response model is 
sufficient for retrieving static assets, applying the same 
stateless communication approach for interactive use cases 
(such as multiplayer games) introduces undesirable 
performance overhead from having to frequently set up 
new connections for client-server interactions. 
Developers have since adopted other communication 
transport abstractions over HTTP connections such as the WebSockets protocol \cite{WebSocketRFC} to enjoy low-latency full-duplex 
client-server communication in their applications over 
a single persistent connection. 
Enabling more complex communication patterns caters for 
more interactive use cases, but introduces additional 
concerns to the developer with respect to implementation correctness.

% Example: noughts and crosses
Consider a classic turn-based board game of \textit{Noughts and Crosses} 
between two players. Both players are identified by either noughts or crosses 
respectively, and take turns to place a mark on an unoccupied cell 
of a 3-by-3 grid until one player wins (when their markers form 
one straight line on the board) or a stalemate is reached 
(when all cells are occupied). A web-based implementation may 
involve players connected to a game server via WebSocket connections 
and interacting with the game from their web browser, which serve 
a \textit{single-page application} (SPA) of the game client written 
in a popular framework like \textit{React.js} \cite{React}. 
SPAs feature a single HTML page and dynamically renders content 
via JavaScript in the browser. 
Players take turns to make a move on the game board and the server 
implements the game logic to progress the game forward until 
a result (either a win/loss or draw) can be declared. 

Whilst WebSockets make this web-based implementation possible, 
it introduces the developer to a new family of communication errors
(in addition to the usual testing for game logic correctness), 
even for this simple game:
we highlight just a few:

\begin{itemize}

\item
\textbf{Deadlocks:} how can we prevent both players waiting for 
each other to make a move at the same time?

\item 
\textbf{Communication mismatches:} what if player 1 sends
a boolean to the game server instead of board coordinates?

\item
\textbf{Channel linearity:} if the game server takes time
to update the game logic and respond to the players, what if 
player 1 clicks the same cell twice and sends the coordinates twice?

\end{itemize}

The complexity of these errors, which correlate to the complexity of tests 
required against these errors, scale with the complexity of the 
communication patterns involved. Over-reliance on integration testing
to attempt to expose communication-related bugs will also slow the
development process, not to mention that the time taken for these
integration tests would scale with the number of roles involved.
A localised, static way for verifying communication correctness would
be highly desirable.

\textit{Multiparty Session Types} (MPST) \cite{MPST} provide 
a framework for formally specifying a structured communication pattern 
between concurrent processes and verifying implementations for 
correctness with respect to the communications aspect. 
By specifying the client-server interactions of our game as a protocol 
and verifying the implementations against the protocol for well-formedness, 
MPST theory guarantees well-formed implementations to be 
free from communication errors.

Existing work \cite{MVU2020,PureScript2019} that 
adapt the MPST framework for web development
acknowledge the limitations of JavaScript -- the language of the browser --
in providing static type-level guarantees, and proceed to use
languages equipped with stronger type systems that compile to JavaScript.
This comes at the cost of a learning curve for the developer,
and limits its utility in the mainstream web development space.

Among the many languages that compile to JavaScript,
TypeScript stands out as the most intuitive to use as it is defined
to be a \textit{superset} of JavaScript. It provides developers
with type-safety through its gradual, structural type system.
Whilst some \cite{MVU2020} point out this limits its usability for
encoding multiparty session types, we believe that the language
offers sufficient features that we can use to provide developers with
communication safety guarantees whilst preserving a flexible, natural
and idiomatic workflow. By building our work upon TypeScript, we
work towards incorporating MPST into mainstream web development,
which reduces development time by programmatically verifying 
implementations for communication correctness.