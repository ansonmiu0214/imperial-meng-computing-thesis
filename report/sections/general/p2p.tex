\chapter{Motivation: Supporting Peer-to-Peer Interactions}
\label{chap:p2p}

In this chapter,
we demonstrate how to support peer-to-peer interactions
between web browser endpoints over WebSocket transport,
thus relaxing the server-centric topology assumption from 
\cref{part:server}.

We motivate the problem using the 
\tprotocol{Two Buyer} protocol (\cref{section:twobuyer}),
outline our approach (\cref{section:routerapproach}),
and discuss the challenges we need to address 
(\cref{section:routerchallenges}) in order to validate the
correctness of our approach.

\section{\tprotocol{Two Buyer} Protocol}
\label{section:twobuyer}

We present the \tprotocol{Two Buyer} protocol in \cref{lst:twobuyer},
which describes a protocol between two buyers \trole{A}, \trole{B}
and a \trole{S}eller. We assume that the \trole{S}eller runs on
the server, and the buyers run on the browser.

\begin{figure}[!ht]
\begin{lstlisting}[language=scribble]
module ClientClient;

global protocol TwoBuyer(role A, role B, role S) {
	title(string)   from A to S;
	quote(number)   from S to A;
	quote(number)   from S to B;
	split(number)   from A to B; (*@\label{line:twobuyersplit}@*)
	choice at B {
		accept()    from B to A; (*@\label{line:twobuyerok}@*)
		buy()       from A to S;
	} or {
		reject()    from B to A; (*@\label{line:twobuyerno}@*)
		cancel()    from A to S;
	}
}
\end{lstlisting}
\captionof{lstlisting}{The \tprotocol{Two Buyer} Protocol}
\label{lst:twobuyer}
\end{figure}

In the protocol, \trole{A} asks the \trole{S}eller for the quote
of a book \tmsg{title}. \trole{S}eller sends the \tmsg{quote}
to both buyers \trole{A} and \trole{B}. \trole{A} privately asks
proposes a \tmsg{split} with \trole{B}. Now, \trole{B} must make
a choice: 
either \trole{B} can \tmsg{accept} the split, where \trole{A} confirms
to \tmsg{buy} from the \trole{S}eller;
otherwise, \trole{B} will \tmsg{reject} the split, which
\tmsg{cancel}s the purchase.

\cref{line:twobuyersplit,line:twobuyerok,line:twobuyerno}
illustrate that the \tprotocol{Two Buyer} protocol 
does not implement a server-centric communication topology,
since these lines reference communication actions between
the two client browsers. 
As a result, \fancyname{SessionTS} cannot correctly generate
APIs that support the specified interactions 
for buyers \trole{A} and \trole{B}.

\section{Proposal: Server as a Router}
\label{section:routerapproach}

We acknowledge that peer-to-peer browser interactions
could be achieved via different transport abstractions, 
such as the WebRTC framework \cite{WebRTC}. 
However, WebRTC has its own proprietary ``protocol'' 
for establishing connections and exchanging network information,
which isn't formalised in session type theory. This setup phase
generally requires a \textit{signalling server} \cite{WebRTCSignaling},
which brings our problem full circle, as it can be implemented
over WebSocket transport. Extending API generation to also include
the boilerplate for initialising WebRTC connections could be an option,
but would introduce complications in the session runtime and
error handling (e.g. how to handle cancellations during the connection
phase?).
We believe that adopting WebRTC deviates from the focus of project in 
implementing type-safe webservices.

Hence, for the purpose of our work in this part,
we establish that WebSocket transport is an invariant, 
and proceed to build up our approach. 
We start by breaking down the concept of 
``peer-to-peer communication''.
Focusing on \cref{lst:twobuyer} \cref{line:twobuyersplit},
we can say that the interaction satisfies three properties:

\begin{enumerate}
\item 
As far as \trole{A} is concerned, \trole{A} is sending
a message that will be received by \trole{B}.

\item
As far as \trole{B} is concerned, \trole{B} is receiving
a message that was sent by \trole{A}.

\item
The \trole{S}eller is not involved in this interaction.
\end{enumerate}

We proceed to relax point 3: for the \trole{S}eller to be
not involved in the interaction, it suffices to guarantee that
the \trole{S}eller cannot intervene or hijack the communication.
This allows \trole{S}eller to ``oversee'' the communication.

On this basis, we motivate our approach to empower the 
server endpoint to act as a \textit{router}. 
That is to say, if the server endpoint receives a message
of which it isn't the intended recipient for, 
it routes the message to the intended recipient. 
Based on the WebSocket transport invariant,
all browser endpoints must join the session
through the server. This means that the server has information about
all browser endpoints, 
and is capable to perform the routing.

Returning to \cref{lst:twobuyer} \cref{line:twobuyersplit},
\trole{A} sends the \tmsg{split} message through its existing
WebSocket connection (with \trole{S}eller on the other side),
noting that \trole{B} is the intended recipient;
\trole{S}eller receives this through the WebSocket bound to
\trole{A}, and routes the message to \trole{B}, who receives it through
its existing connection with \trole{S}eller.
It is trivial that the three properties\footnote{Here, we use the relaxed
version of point 3 mentioned previously.} listed previously are still
satisfied: 

\begin{enumerate}
\item
\textit{As far as \trole{A} is concerned, \trole{A} is sending
a message that will be received by \trole{B}} -- 
the intended recipient is specified in the message.

\item
\textit{As far as \trole{B} is concerned, \trole{B} is receiving
a message that was sent by \trole{A}} --
the original sender is specified in the message.

\item
\textit{\trole{S}eller cannot intervene or hijack the communication} --
this remains true, as \trole{S}eller simply receives the message
from the WebSocket bound to \trole{A} and sends it through the
WebSocket bound to \trole{B}.

\end{enumerate}

\section{Challenges}
\label{section:routerchallenges}

We need to formalise our concept of routing by extending session
type theory, such that, given a communication protocol implementing 
an arbitrary topology, we can encode it into our extended theory and
prove that safety properties (e.g. well-formedness, deadlock freedom)
are preserved, and that communication traces are preserved.
This must be done \textit{very carefully}, as
naive definitions risk over-serialising the original communication,
thereby not preserving all communication traces.

\begin{example}[Naive definition of routing in global types]
Consider the global type
\[
A \to B: \tmsg{M1}. S \to B: \tmsg{M2}. \texttt{end}
\]
By existing LTS semantics over
global types (\cref{subsubsection:lts}), then $SB!\tmsg{M2}$
is a prefix of a valid execution trace.
If we define our routing construct simply by replacing every single
$A \to B: \tmsg{M}$ interaction with $A \to S: \tmsg{M}.
S \to B: \tmsg{M}$, we transform the global type into
\[
A \to S: \tmsg{M1}. S \to B: \tmsg{M1}. S \to B: \tmsg{M2}. \texttt{end}
\]
our naive definition of routing has over-serialised the protocol
since $SB!\tmsg{M2}$ can no longer occur first because \trole{S}
is forced to send \tmsg{M1} first, which it cannot do so until receiving
from \trole{A}.
This implies that we need to handle routing interactions differently
from ``normal'' send/receive actions.
\end{example}

Existing work in decomposing multiparty sessions into a collection
of binary sessions do resemble our routing proposal, but their approach
involves having an endpoint to exclusively carry out
routing responsibilities and act as a centralised orchestrator 
for the multiparty session.
Our proposal recognises that, in the context of web applications,
there is a need for server-side endpoints to implement business logic
so enforcing the server to be an exclusive orchestrator makes our work
incompatible with webservice protocols; 
we also argue that the server can still participate in the 
multiparty session and concurrently perform its routing duties
in a way that is transparent to non-server endpoints, and crucially,
does not overserialise the permitted interactions. 
We introduce our extension as \textit{Routed Session Types},
and proceed to prove these claims in \cref{chap:theory}.

Likewise, the implementation of routed session types 
in \fancyname{SessionTS} needs to accurately reflect the theory
and be as transparent to the developer as possible to minimise
the learning curve overhead demanded 
by complicating the generated APIs -- we document our extensions
to \fancyname{SessionTS} in \cref{chap:impl}.