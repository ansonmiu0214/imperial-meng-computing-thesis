\chapter{Implementing \newtheory in \codegen}
\label{chap:impl}

In this chapter, we
explain how \codegen
is extended to implement \newtheory.
As motivated in \cref{section:routerapproach},
the routing mechanism is intended to be transparent
to the developer.
Hence, there are \textit{no changes} made to the
generated APIs; we only need to adapt
how the session runtime of the respective
endpoints perform send and receive actions.
We present the changes made to the session
runtime generated by \nodecodegen
and \reactcodegen in 
\cref{section:routednode,section:routedreact}
respectively.

\section{Extending \nodecodegen}
\label{section:routednode}

By enabling peer-to-peer communication
between browser endpoints through the server,
not all messages received by the server are intended
for the server role.
We distinguish these by requiring all messages sent
by browser endpoints to specify the intended recipient
under the \texttt{role} property.
We specify this through constructing an interface
defining the structure of a 
``general'' message received by the 
server.
Since this interface must match \textit{both}
routed messages and messages intended for the server,
we have to respect the fact that the server
does not need to know the contents of routed messages,
so the existing \texttt{label}
and \texttt{payload} properties must be loosely typed
to respect this notion of privacy.

\begin{lstlisting}[language=javascript]
// Inside the Message namespace...
export interface Channel {
	role: Roles.All, label: string, payload: any[]
};

// Build message object to send through WebSocket
export const toChannel = 
	(role: Roles.All, label: string, payload: any[]) => ({
	role, label, payload
});
\end{lstlisting}

We can now adapt the \texttt{onmessage}
WebSocket event listener defined at the server endpoint
to route messages not intended for the server role,
as shown in \cref{lst:noderoutereceive}.
By construction of our API generation strategy,
the incoming message must match the interface defined
above, so it is a safe deserialisation step.
This preliminary deserialisation allows the server
to identify \textit{routed messages}, and proceed to
send it to the intended recipient.

\begin{figure}[!h]
\begin{lstlisting}[language=javascript]
// Top-level parsing to distinguish between routed messages
const { role, label, payload } = 
	JSON.parse(data) as Message.Channel;
if (role !== Roles.Self) {
	// Route message
	this.send(role, label, payload, from);
} else {
	// Invoke message handler as before, see (*@\cref{subsection:noderuntimereceive}@*)
}
\end{lstlisting}
\captionof{lstlisting}{Modified \texttt{onmessage} Event Listener for
\nodecodegen for Routing}
\label{lst:noderoutereceive}
\end{figure}

Browser endpoints also expect to receive messages
with the original sender explicitly marked under 
the \texttt{role} property, so we modify the 
\texttt{send()} method generated for the server endpoint
to attach this extra piece of information.
To maximise compatibility with the existing runtime
implementation, we define the server as the default 
argument for the \texttt{from} parameter
of the \texttt{send()} method, as highlighted below.

\begin{lstlisting}[language=javascript]
send(to: Roles.Peers, label: string, payload: any[], 
	(*@\hl{from: Roles.All = Roles.Self}@*)) {
	const message = Message.toChannel(from, label, payload);
	this.roleToSocket[to].send(JSON.stringify(message));
}
\end{lstlisting}

\newtheory introduces an additional concern for managing
the terminal state of the server's EFSM:
when the server's EFSM reaches its terminal state,
it does not mean other endpoints have reached their terminal state,
as they can still interact amongst themselves.
The server will need to remain connected to perform its routing duties.
As our existing design choice already specifies that browser
endpoints initiate the WebSocket close event when they reach
their terminal state, we do not need to worry about this
additional concern as the server will remain connected
when it reaches its terminal state to carry out its routing
duties anyway.


\section{Extending \reactcodegen}
\label{section:routedreact}

Similarly, the session runtime for browser endpoints need
to specify the intended recipient when sending a message through the
WebSocket connection, in order for the server endpoint to route the message accordingly.
Likewise, when registering receive handlers, the browser endpoint also 
needs to specify the role to receive from in addition to the handler.

As explained in \cref{subsection:reactruntimereceive},
the current implementation of \reactcodegen has a pair of
queues for messages waiting for handlers and vice-versa.
Because \newtheory allows browser endpoints to interact
with non-server endpoints, this existing framework may
lead to communication mismatch.

For example, consider the sequence of routed interactions between
server endpoint $S$ and \textit{browser} endpoints $A$, $B$ and $C$:
\[
A \xrightarrow[S]{} B : \text{\lstonelinejs{M1(number)}}. 
C \xrightarrow[S]{} B : \text{\lstonelinejs{M2(string)}}. \texttt{end}
\]
 
From the perspective of $B$, $B$ will register a receive handler expecting
to process \lstonelinejs{M1(number)} from $A$ first.
However, communication will be routed by
some server endpoint $S$, and by \newtheory theory, $S$ can route 
$C$'s \lstonelinejs{M2(string)} message
to $B$ before $A$'s \lstonelinejs{M1(number)} message, 
so the existing message receiving framework
will use the receive handler defined for \lstonelinejs{M1(number)}
to process the received \lstonelinejs{M2(string)}, which is a mismatch.

Hence, we need to implement
the message receiving framework outlined in 
\cref{subsection:noderuntimereceive}
instead, which generalises the pair of message/handler queues to two mappings
to provide a pair of message/handler queues for each endpoint.
The runtime instantiates the two mappings of queues,
and receive handler registration now targets the pair of queues
specified by the role to receive from.
We illustrate this in \cref{lst:reactrouterreceive}

\begin{figure}[!h]
\begin{lstlisting}[language=javascript]
class Client extends React.Component<...> {
	private messageQueue: RoleToMessageQueue;
    private handlerQueue: RoleToHandlerQueue;
    
    // Omitting unchanged methods
    
	private registerReceiveHandler(
		role: Roles.Peers, handle: ReceiveHandler) { 
		const message = this.messageQueue[role].shift();
		if (message !== undefined) {
			// Message received already -- process as before
		} else {
			// No message received -- enqueue handler
			this.handlerQueue[role].push(handle);
		}
	}
}
\end{lstlisting}
\captionof{lstlisting}{Runtime Extensions for \reactcodegen to Implement \newtheory}
\label{lst:reactrouterreceive}
\end{figure}

Referring to the previous example under this framework,
$S$ can route $C$'s message to $B$ first, 
but \lstonelinejs{M2(string)} will be stored
under the message queue mapped to $C$, 
so it will not be processed until $B$ registers
the receive handler for processing $C$'s message. 
This cannot happen until $B$ processes
\lstonelinejs{M1(number)} from $A$, so the order of communication 
specified in the global protocol is respected.
